% This is a sample document using the University of Minnesota, Morris, Computer Science
% Senior Seminar modification of the ACM sig-alternate style. Much of this content is taken
% directly from the ACM sample document illustrating the use of the sig-alternate class. Certain
% parts that we never use have been removed to simplify the example, and a few additional
% components have been added.

% See https://github.com/UMM-CSci/Senior_seminar_templates for more info and to make
% suggestions and corrections.

\documentclass{sig-alternate}
\usepackage{color}

%%%% User-defined macros
\newcommand{\lam}{\lambda}
\newcommand{\mycomment}[1]{\textcolor{red}{#1}}
\newcommand{\vm}[0]{virtual machine}
%%%%% Uncomment the following line and comment out the previous one
%%%%% to remove all comments
%%%%% NOTE: comments still occupy a line even if invisible;
%%%%% Don't write them as a separate paragraph
%\newcommand{\mycomment}[1]{}

\begin{document}

% --- Author Metadata here ---
%%% REMEMBER TO CHANGE THE SEMESTER AND YEAR
\conferenceinfo{UMM CSci Senior Seminar Conference, April 2014}{Morris, MN}

\title{Programming Language Interoperability}

\numberofauthors{1}

\author{
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
\alignauthor
Todd Malone\\
	\affaddr{Division of Science and Mathematics}\\
	\affaddr{University of Minnesota, Morris}\\
	\affaddr{Morris, Minnesota, USA 56267}\\
	\email{malon153@morris.umn.edu}
}

\maketitle
\begin{abstract}
\mycomment{A discussion of systems and methods for the interop of programming languages}
\end{abstract}

\keywords{interoperability, language interoperability, programming language}

\section{Introduction}
Interoperability, colloquially shortened to interop, is the ability for for two or more systems to work together. This definition is very broad, covering anything from groups of people to business or bureaucratic systems to pieces of hardware. Here we will be focusing on the interoperability of programming languages.

In section \ref{Interop} I'll explore why interoperability is desirable, what advantages it can confer, and where it can be useful. This will touch on differing language capabilities, ease of use, hardware independence, and implications for distributed computing.

Next, in sections \ref{VM} and \ref{ML}, I'll describe two particular settings \mycomment{settings / approaches / systems} that are used when trying to achieve interoperability, and defining relevant aspects of these settings. These settings will be virtual machines, paying particular attention to the Java Virtual Maching (JVM) and .NET's Common Language Runtime (CLR), and markup languages, with focus on two particular systems that make use of markup languages, Starlink and FML.

Section \ref{approaches} will detail particular challenges to achieving interoperability and approaches to handling them. Following a general description of the approach, I will describe how each setting \mycomment{setting / approach / system} can be used to implement that approach, along with strengths and weaknesses of each setting.


\section{Interoperability}\label{Interop}
This section will discuss why interoperability is important or desirable.
\begin{itemize}
	\item problem domain: languages have libraries and capabilities build for specific problems. This gives them strength in that area (such as SQL database queries?), but often they have weaknesses in other areas (such as Erlang's strings).
	\item level(?): some languages have finer-grained control over storage (like the C family), while others deal with more abstract and generalize-able data structures (like... java or ruby).
	\item hardware independence: while interoperability doesn't require this, they frequently go hand in hand. An Interop standard between two languages also means the two languages can run on different hardware without the standard caring.
\end{itemize}


\section{Virtual Machines}\label{VM}
This section will be a short background on virtual machine environments. This should cover what a virtual machine is (briefly), and the sort of things VM environments add to programming languages. Examples may include JIT compilers, memory management, a common base language...

\section{Markup Languages}\label{ML}
This section will have an introduction to markup languages. I don't expect this section to be very long. Perhaps this and VM should be subsections under a "systems" section?

\section{Difficulties and Approaches}\label{approaches}
In order to attain interoperability, there are several major things that systems need to account for. Of primary concern is the lowest common denominator constraint. All languages involved in a interoperating system must be prepared to deal with the language with the most stringent typing data representation or typing system. 

\subsection{Metadata and Data Type Conversion} \cite{Ide:2010, Bromberg:2011, Hamilton:2003}
One of the most basic things an interoperating system needs to take into account are the data types involved. 
When passing data between two languages, a system needs to have a way of ensuring that the type restrictions of the LCD are respected. Ide and Pustejovsky \cite{Ide:2010} suggest metadata as the method to accomplish this, and in practice is what both styles use. Metadata is simply data about the data. This can be used to impart type information to languages that have no concept of types, or in addition type information when a typed language needs to interact with a another, more strictly typed language.
\mycomment{Here I can also talk about syntactic/semantic labels/categories via \cite{Ide:2010}. In fact, definitely talk about this. VMs have the advantage of virtually ensuring semantic interoperability because all execution is done through the same language}
\subsubsection*{VMs and metadata}
Virtual machines deal with the concept of metadata in two primary ways. This is mainly handled at compile time by the compiler itself, but this is handled differently depending on the underlying virtual machine.
\begin{itemize}
\item JVM: mainly make use of Java types. For less strictly-typed languages like Ruby, this means mostly using the Java Object class and using reflection \mycomment{magic} to ensure correct runtime behavior. This is actually a circumvention of the metadata concept, in order to avoid the LCD constraint. In other cases, the metadata is provided by bytecode's built-in typing system. If bytecode is the lowest common denominator in the system, 
\item CLR: In the CLR, however, a compiler generates metadata about the program along side the compiled program\cite{Hamilton:2003}.
\end{itemize}

\subsubsection*{MLs and metadata}
Markup languages are, in comparison, comprised entirely of metadata. Data to be transferred between languages can be surrounded in tags, which then act as the metadata, describing what data is contained within them. An advantage to the tag structure is that tags can be nested to describe components of larger data structures, including descriptions of full objects. 


\subsection{Standards and Interfaces} \cite{Shetty:2009}
Metadata is the core of successful interoperability. But if two systems attempting to communicate are expecting differently tagged data, they will still fail to interoperate. Metadata alone is not enough.

One example of this, as demonstrated by Shetty and Vadivel \cite{Shetty:2009}, occurs when trying to process web page output from Java and .NET services. \mycomment{I'm not sure if this is an example I should actually use. Or if I have any examples here}

\subsubsection*{VMs and Standardization}
In a virtual machine system, the standard is frequently already set.\footnote{This is not always the case, but is common practice with recent VMs with the goal of interop.} Virtual machines come with their intermediate language with its own libraries and type systems. These essentially form the standard: each language hoping to run on a particular virtual machine must be translatable to the intermediate language, which can be used as a sort of lingua franca. Any language built to run on the VM should be able, with little additional effort, be able to interoperate with any other language on that VM.


\subsubsection*{MLs and Standardization}
Standards are not inherent to markup languages, nor can they be directly enforced, as they can in a virtual machine setting. Instead, a standard must be implemented within the systems intended to interoperate, or at their data generation points.

\mycomment{Starlink}



\subsection{Error Handling}

\subsubsection*{VMs and Errors}

\subsubsection*{MLs and errors}



\section{Conclusions}
ideas for conclusions:

\begin{itemize}
\item Usage areas: It seems that MLs and VMs have different applicable systems. VMs are more feasible for systems that are being newly built, or which already use a language already attached to a VM. Additionally, they seem more suited to systems that have access to all the component programs, or which are expecting to run on a single machine.

MLs, on the other hand, seem better suited to dealing with preexisting systems, where a rewrite or a compiler change isn't feasible. One reason for this could be that the existing system is on a particular VM, and uses multiple languages, and needs to interop with a system that similarly can't target that VM. Another area MLs are useful is in distributed systems, where each component has no reason to know what language or platform the other components are running.

\end{itemize}


%\section{Acknowledgments}


% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
% sample_paper.bib is the name of the BibTex file containing the
% bibliography entries. Note that you *don't* include the .bib ending here.
\bibliography{bibliography}  
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references

\end{document}
